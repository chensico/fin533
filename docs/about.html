<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>About Our Strategy – Buylowsellsmart</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-ddd961a2510921635943dfbbd19534c4.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Buylowsellsmart</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./about.html" aria-current="page"> 
<span class="menu-text">About Our Strategy</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#our-trading-philosophy" id="toc-our-trading-philosophy" class="nav-link active" data-scroll-target="#our-trading-philosophy">Our Trading Philosophy</a>
  <ul class="collapse">
  <li><a href="#market-inefficiencies-we-target" id="toc-market-inefficiencies-we-target" class="nav-link" data-scroll-target="#market-inefficiencies-we-target">Market Inefficiencies We Target</a></li>
  </ul></li>
  <li><a href="#strategy-framework" id="toc-strategy-framework" class="nav-link" data-scroll-target="#strategy-framework">Strategy Framework</a>
  <ul class="collapse">
  <li><a href="#the-three-entry-conditions" id="toc-the-three-entry-conditions" class="nav-link" data-scroll-target="#the-three-entry-conditions">The Three Entry Conditions</a></li>
  <li><a href="#the-four-exit-signals" id="toc-the-four-exit-signals" class="nav-link" data-scroll-target="#the-four-exit-signals">The Four Exit Signals</a></li>
  </ul></li>
  <li><a href="#implementation-details" id="toc-implementation-details" class="nav-link" data-scroll-target="#implementation-details">Implementation Details</a>
  <ul class="collapse">
  <li><a href="#technical-indicators" id="toc-technical-indicators" class="nav-link" data-scroll-target="#technical-indicators">Technical Indicators</a></li>
  <li><a href="#entry-logic" id="toc-entry-logic" class="nav-link" data-scroll-target="#entry-logic">Entry Logic</a></li>
  <li><a href="#exit-logic" id="toc-exit-logic" class="nav-link" data-scroll-target="#exit-logic">Exit Logic</a></li>
  <li><a href="#risk-management" id="toc-risk-management" class="nav-link" data-scroll-target="#risk-management">Risk Management</a></li>
  <li><a href="#optimization-results" id="toc-optimization-results" class="nav-link" data-scroll-target="#optimization-results">Optimization Results</a></li>
  </ul></li>
  <li><a href="#best-market-conditions" id="toc-best-market-conditions" class="nav-link" data-scroll-target="#best-market-conditions">Best Market Conditions</a></li>
  <li><a href="#about-the-team" id="toc-about-the-team" class="nav-link" data-scroll-target="#about-the-team">About the Team</a></li>
  <li><a href="#beyond-the-backtests" id="toc-beyond-the-backtests" class="nav-link" data-scroll-target="#beyond-the-backtests">Beyond the Backtests</a></li>
  <li><a href="#key-formula-explanations" id="toc-key-formula-explanations" class="nav-link" data-scroll-target="#key-formula-explanations">Key Formula Explanations</a></li>
  <li><a href="#detailed-strategy-implementation" id="toc-detailed-strategy-implementation" class="nav-link" data-scroll-target="#detailed-strategy-implementation">Detailed Strategy Implementation</a>
  <ul class="collapse">
  <li><a href="#core-trading-logic" id="toc-core-trading-logic" class="nav-link" data-scroll-target="#core-trading-logic">Core Trading Logic</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">About Our Strategy</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<style>
/* Formula styling */
.formula-container {
  background-color: #f8f9fa;
  padding: 1rem 1.5rem;
  border-radius: 0.5rem;
  margin: 1.5rem 0;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
  text-align: center;
}

.formula-title {
  font-weight: 600;
  color: #2c3e50;
  margin-bottom: 0.5rem;
  font-size: 1.1rem;
}
</style>
<section id="our-trading-philosophy" class="level2">
<h2 class="anchored" data-anchor-id="our-trading-philosophy">Our Trading Philosophy</h2>
<p>Our research is based on a key market principle: <strong>prices typically return to their average after extreme movements</strong>. Our “Buy Low / Sell High” strategy captures these reversion opportunities using a structured, evidence-based approach.</p>
<section id="market-inefficiencies-we-target" class="level3">
<h3 class="anchored" data-anchor-id="market-inefficiencies-we-target">Market Inefficiencies We Target</h3>
<p>Our strategy takes advantage of two common market patterns:</p>
<ol type="1">
<li><p><strong>Overreaction to News</strong>: Markets often overreact to short-term negative news, creating buying opportunities in fundamentally strong assets.</p></li>
<li><p><strong>Support Level Bounces</strong>: Prices frequently rebound when they reach statistical support levels (such as Bollinger Bands) during uptrends.</p></li>
</ol>
</section>
</section>
<section id="strategy-framework" class="level2">
<h2 class="anchored" data-anchor-id="strategy-framework">Strategy Framework</h2>
<p>Instead of explaining every technical detail (available in our <a href="index.html">main analysis</a>), we present the core concepts:</p>
<section id="the-three-entry-conditions" class="level3">
<h3 class="anchored" data-anchor-id="the-three-entry-conditions">The Three Entry Conditions</h3>
<p>Our strategy only enters a position when all three conditions are met:</p>
<ul>
<li><strong>Confirmed Uptrend</strong>: We only buy when the market trend is clearly positive</li>
<li><strong>Oversold Indicators</strong>: We require technical evidence of oversold conditions</li>
<li><strong>Price at Support</strong>: We need confirmation that price has reached a support level</li>
</ul>
</section>
<section id="the-four-exit-signals" class="level3">
<h3 class="anchored" data-anchor-id="the-four-exit-signals">The Four Exit Signals</h3>
<p>Our disciplined exit approach responds to any of these market signals:</p>
<ul>
<li><strong>Target Reached</strong>: The asset has become overbought</li>
<li><strong>Stop Loss Hit</strong>: The price has fallen below our predefined risk level</li>
<li><strong>Take Profit Triggered</strong>: The price has reached our profit target</li>
<li><strong>Trend Reversal</strong>: The short-term trend direction has changed</li>
</ul>
</section>
</section>
<section id="implementation-details" class="level2">
<h2 class="anchored" data-anchor-id="implementation-details">Implementation Details</h2>
<p>For those interested in the technical aspects, here is a simplified explanation:</p>
<section id="technical-indicators" class="level3">
<h3 class="anchored" data-anchor-id="technical-indicators">Technical Indicators</h3>
<ul>
<li><strong>Moving Averages</strong>: 50-day and 200-day SMAs confirm trend direction</li>
<li><strong>RSI</strong>: 14-period Relative Strength Index identifies oversold conditions</li>
<li><strong>Bollinger Bands</strong>: 20-period with 2 standard deviations marks statistical extremes</li>
<li><strong>ATR</strong>: 14-period Average True Range enables dynamic risk management</li>
</ul>
</section>
<section id="entry-logic" class="level3">
<h3 class="anchored" data-anchor-id="entry-logic">Entry Logic</h3>
<p>The system generates a BUY signal when ALL these conditions are met:</p>
<pre><code>IF (SMA50 &gt; SMA200) AND (RSI &lt; 35) AND (Price &lt;= Lower Bollinger Band) THEN BUY</code></pre>
</section>
<section id="exit-logic" class="level3">
<h3 class="anchored" data-anchor-id="exit-logic">Exit Logic</h3>
<p>The system generates a SELL signal when ANY of these conditions occur:</p>
<pre><code>IF (RSI &gt; 70) OR (Price &lt; Stop Loss) OR (Price &gt; Take Profit) OR (Price &lt; SMA50) THEN SELL</code></pre>
</section>
<section id="risk-management" class="level3">
<h3 class="anchored" data-anchor-id="risk-management">Risk Management</h3>
<ul>
<li>Position Size: 2% of portfolio per trade</li>
<li>Stop Loss: Entry Price - (2.0 × ATR)</li>
<li>Take Profit: Entry Price + (5.0 × ATR)</li>
</ul>
</section>
<section id="optimization-results" class="level3">
<h3 class="anchored" data-anchor-id="optimization-results">Optimization Results</h3>
<p>After extensive testing, our best parameter combination achieved: - 55.41% Win Rate - 12.88% Total Return (during test period) - 2.37% Maximum Drawdown - 0.95 Sharpe Ratio (highest among all tested combinations)</p>
<p>The strategy showed excellent performance with minimal drawdown, providing a solid foundation for further development.</p>
</section>
</section>
<section id="best-market-conditions" class="level2">
<h2 class="anchored" data-anchor-id="best-market-conditions">Best Market Conditions</h2>
<p>Our backtesting shows this strategy works best in:</p>
<ul>
<li><strong>Range-bound markets</strong> with definite technical boundaries</li>
<li><strong>Bullish markets</strong> with regular pullbacks</li>
<li><strong>Low-volatility environments</strong> with measured price movements</li>
</ul>
<p>The strategy adapts to changing market conditions through its ATR-based parameters, automatically adjusting position size and risk levels as volatility changes.</p>
</section>
<section id="about-the-team" class="level2">
<h2 class="anchored" data-anchor-id="about-the-team">About the Team</h2>
<p><strong>Sicong Chen</strong> specializes in quantitative strategy development with expertise in technical analysis and market microstructure. His research focuses on mean-reversion strategies and statistical arbitrage.</p>
<p><strong>Yuxin Wan</strong> brings expertise in risk modeling and portfolio optimization. Her work focuses on robust backtesting methods and testing parameter stability across different market conditions.</p>
<p>Together, we combine technical analysis with statistical methods to create trading strategies that perform consistently in changing market environments.</p>
</section>
<section id="beyond-the-backtests" class="level2">
<h2 class="anchored" data-anchor-id="beyond-the-backtests">Beyond the Backtests</h2>
<p>While our <a href="index.html">detailed analysis</a> provides complete performance metrics, we understand that successful strategy implementation requires more than just good backtest results:</p>
<ul>
<li><p><strong>Psychological Factors</strong>: The 55.41% win rate and small drawdowns make this strategy psychologically manageable for most traders.</p></li>
<li><p><strong>Simple Execution</strong>: With clear rules and typically 1-day holding periods, this strategy is straightforward to implement.</p></li>
<li><p><strong>Diversification Potential</strong>: This approach can be applied to multiple assets and timeframes for portfolio diversification.</p></li>
<li><p><strong>Learning Value</strong>: The strategy demonstrates fundamental market principles, making it valuable for education purposes.</p></li>
</ul>
<p>For detailed backtesting results, parameter optimization analysis, and technical implementation, please visit our <a href="index.html">main strategy page</a>.</p>
</section>
<section id="key-formula-explanations" class="level2">
<h2 class="anchored" data-anchor-id="key-formula-explanations">Key Formula Explanations</h2>
<div class="formula-container">
<div class="formula-title">
<p>Relative Strength Index (RSI) Calculation</p>
</div>
<p><span class="math display">\text{RSI} = 100 - \frac{100}{1 + \frac{\text{Average Gain}}{\text{Average Loss}}}</span></p>
<p>Where: - Average Gain = Average of all up moves in the look-back period - Average Loss = Average of all down moves in the look-back period</p>
</div>
<div class="formula-container">
<div class="formula-title">
<p>Average True Range (ATR) for Risk Management</p>
</div>
<p><span class="math display">\text{ATR} = \frac{1}{n} \sum_{i=1}^{n} \text{TR}_i</span></p>
<p><span class="math display">\text{TR} = \max((\text{High} - \text{Low}), |(\text{High} - \text{Previous Close})|, |(\text{Low} - \text{Previous Close})|)</span></p>
</div>
<div class="formula-container">
<div class="formula-title">
<p>Dynamic Stop Loss &amp; Take Profit Calculation</p>
</div>
<p><span class="math display">\text{Stop Loss} = \text{Entry Price} - \text{ATR} \times \text{Stop Multiplier}</span> <span class="math display">\text{Take Profit} = \text{Entry Price} + \text{ATR} \times \text{Take Multiplier}</span></p>
</div>
</section>
<section id="detailed-strategy-implementation" class="level2">
<h2 class="anchored" data-anchor-id="detailed-strategy-implementation">Detailed Strategy Implementation</h2>
<section id="core-trading-logic" class="level3">
<h3 class="anchored" data-anchor-id="core-trading-logic">Core Trading Logic</h3>
<p>The “Buy Low Sell High” strategy is designed to identify temporary price dips in uptrending markets, entering long positions when prices are oversold according to technical indicators, and exiting based on predefined conditions.</p>
<section id="entry-conditions" class="level4">
<h4 class="anchored" data-anchor-id="entry-conditions">Entry Conditions</h4>
<p>For a trade entry signal to be generated, ALL of the following conditions must be met simultaneously:</p>
<ol type="1">
<li><p><strong>Confirmed Uptrend</strong>: The 50-day Simple Moving Average must be above the 200-day Simple Moving Average (<code>SMA50 &gt; SMA200</code>), indicating an overall bullish market structure.</p></li>
<li><p><strong>Oversold Condition</strong>: The 14-period Relative Strength Index (RSI) must fall below the optimized threshold value (35 in our optimal configuration), indicating a temporary oversold condition.</p></li>
<li><p><strong>Price at Support</strong>: The closing price must touch or fall below the lower Bollinger Band (20-period, 2 standard deviations), confirming price is at a statistical support level.</p></li>
</ol>
<p>When all three conditions are satisfied, the system: - Generates a BUY signal - Sets entry price at the current closing price - Calculates position size at 2% of the portfolio value - Establishes dynamic stop-loss and take-profit levels based on the Average True Range (ATR)</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Entry logic from generate_signals() function</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (df_signals.iloc[i][<span class="st">'SMA50'</span>] <span class="op">&gt;</span> df_signals.iloc[i][<span class="st">'SMA200'</span>] <span class="kw">and</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    df_signals.iloc[i][<span class="st">'RSI'</span>] <span class="op">&lt;</span> rsi_threshold <span class="kw">and</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    df_signals.iloc[i][<span class="st">'Close'</span>] <span class="op">&lt;=</span> df_signals.iloc[i][<span class="st">'BB_Lower'</span>]):</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Generate buy signal and set parameters</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    entry_price <span class="op">=</span> df_signals.iloc[i][<span class="st">'Close'</span>]</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    atr_value <span class="op">=</span> df_signals.iloc[i][<span class="st">'ATR'</span>]</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    df_signals.iloc[i, df_signals.columns.get_loc(<span class="st">'Signal'</span>)] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    df_signals.iloc[i, df_signals.columns.get_loc(<span class="st">'Stop_Loss'</span>)] <span class="op">=</span> entry_price <span class="op">-</span> <span class="fl">2.0</span> <span class="op">*</span> atr_value</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    df_signals.iloc[i, df_signals.columns.get_loc(<span class="st">'Take_Profit'</span>)] <span class="op">=</span> entry_price <span class="op">+</span> <span class="fl">5.0</span> <span class="op">*</span> atr_value</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="exit-conditions" class="level4">
<h4 class="anchored" data-anchor-id="exit-conditions">Exit Conditions</h4>
<p>The strategy exits an open position when ANY of the following conditions occur:</p>
<ol type="1">
<li><p><strong>RSI Overbought</strong>: If RSI rises above 70, indicating the asset has become overbought.</p></li>
<li><p><strong>Stop-Loss Triggered</strong>: If price falls below the calculated stop-loss level (Entry Price - ATR × Stop Multiplier).</p></li>
<li><p><strong>Take-Profit Triggered</strong>: If price rises above the calculated take-profit level (Entry Price + ATR × Take Multiplier).</p></li>
<li><p><strong>Trend Reversal</strong>: If price closes below the 50-day Simple Moving Average (SMA50), suggesting the shorter-term trend may be reversing.</p></li>
</ol>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Exit logic from generate_signals() function</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> df_signals.iloc[i][<span class="st">'Signal'</span>] <span class="op">==</span> <span class="dv">1</span> <span class="kw">and</span> df_signals.iloc[i][<span class="st">'RSI'</span>] <span class="op">&gt;</span> <span class="dv">70</span>:</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    df_signals.iloc[i, df_signals.columns.get_loc(<span class="st">'Signal'</span>)] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Exit: RSI overbought</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="cf">elif</span> df_signals.iloc[i][<span class="st">'Signal'</span>] <span class="op">==</span> <span class="dv">1</span> <span class="kw">and</span> df_signals.iloc[i][<span class="st">'Low'</span>] <span class="op">&lt;=</span> df_signals.iloc[i][<span class="st">'Stop_Loss'</span>]:</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    df_signals.iloc[i, df_signals.columns.get_loc(<span class="st">'Signal'</span>)] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Exit: Stop-loss triggered</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="cf">elif</span> df_signals.iloc[i][<span class="st">'Signal'</span>] <span class="op">==</span> <span class="dv">1</span> <span class="kw">and</span> df_signals.iloc[i][<span class="st">'High'</span>] <span class="op">&gt;=</span> df_signals.iloc[i][<span class="st">'Take_Profit'</span>]:</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    df_signals.iloc[i, df_signals.columns.get_loc(<span class="st">'Signal'</span>)] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Exit: Take-profit triggered</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="cf">elif</span> df_signals.iloc[i][<span class="st">'Signal'</span>] <span class="op">==</span> <span class="dv">1</span> <span class="kw">and</span> df_signals.iloc[i][<span class="st">'Close'</span>] <span class="op">&lt;</span> df_signals.iloc[i][<span class="st">'SMA50'</span>]:</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    df_signals.iloc[i, df_signals.columns.get_loc(<span class="st">'Signal'</span>)] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Exit: Close below SMA50</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="position-sizing-and-risk-management" class="level4">
<h4 class="anchored" data-anchor-id="position-sizing-and-risk-management">Position Sizing and Risk Management</h4>
<ul>
<li><strong>Fixed Risk Percentage</strong>: Each trade risks 2% of the portfolio value (<code>Position_Size = 0.02</code>)</li>
<li><strong>Dynamic Stop-Loss</strong>: Calculated using ATR to adapt to market volatility (<code>Stop_Loss = Entry_Price - ATR × Stop_Multiplier</code>)</li>
<li><strong>Asymmetric Reward-Risk Ratio</strong>: Take-profit level is set at a multiple of the stop-loss distance (optimal parameters found: 2.0× ATR for stop-loss, 5.0× ATR for take-profit, resulting in a 2.5:1 reward-to-risk ratio)</li>
</ul>
</section>
<section id="parameter-optimization-process" class="level4">
<h4 class="anchored" data-anchor-id="parameter-optimization-process">Parameter Optimization Process</h4>
<p>The strategy employs grid-search optimization across three key parameters: - <strong>RSI Threshold</strong>: Tested values of 30, 35, 40, and 45 - <strong>ATR Stop Multiplier</strong>: Tested values of 1.5, 2.0, 2.5, and 3.0 - <strong>ATR Take Multiplier</strong>: Tested values of 3.0, 4.0, and 5.0</p>
<p>Each parameter combination is evaluated based on: - Sharpe Ratio (primary optimization metric) - Total Return - Maximum Drawdown - Win Rate - Number of Trades</p>
<p>The optimal parameter combination (RSI=35, Stop=2.0×ATR, Take=5.0×ATR) was selected based on maximizing the Sharpe Ratio, which balances return against risk.</p>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>